<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Cursor for Product Managers — Working Tool</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #111827;
        --panel-2: #1f2937;
        --line: #334155;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #22d3ee;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, Segoe UI, Arial, Helvetica, sans-serif;
        background: linear-gradient(180deg, #020617 0%, #0b1220 100%);
        color: var(--text);
      }
      .wrap {
        max-width: 1320px;
        margin: 0 auto;
        padding: 22px 16px 32px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 2rem;
      }
      .subtitle {
        margin: 0 0 14px;
        color: var(--muted);
      }
      .status {
        margin: 0 0 18px;
        color: var(--accent);
        font-size: 0.95rem;
      }
      .layout {
        display: grid;
        gap: 16px;
      }
      @media (min-width: 1100px) {
        .layout {
          grid-template-columns: 420px 1fr;
        }
      }
      .panel {
        background: rgba(17, 24, 39, 0.92);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 14px;
      }
      .panel h2 {
        margin: 0 0 10px;
        font-size: 1.05rem;
      }
      label {
        display: block;
        margin: 10px 0 6px;
        font-weight: 600;
      }
      textarea,
      input[type="text"],
      select,
      input[type="file"] {
        width: 100%;
        color: var(--text);
        background: #0f172a;
        border: 1px solid #475569;
        border-radius: 8px;
        padding: 10px;
      }
      textarea {
        min-height: 88px;
        resize: vertical;
      }
      .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }
      button {
        border: 0;
        border-radius: 8px;
        padding: 9px 12px;
        font-weight: 700;
        cursor: pointer;
      }
      .btn-primary {
        background: var(--accent);
        color: #06232b;
      }
      .btn-secondary {
        background: #0f172a;
        color: var(--text);
        border: 1px solid #475569;
      }
      .result-grid {
        display: grid;
        gap: 12px;
      }
      .card {
        background: rgba(31, 41, 55, 0.9);
        border: 1px solid #475569;
        border-radius: 10px;
        padding: 12px;
      }
      .card h3 {
        margin: 0 0 8px;
        color: var(--accent);
      }
      .small {
        color: var(--muted);
        font-size: 0.92rem;
      }
      ul {
        margin: 8px 0 0;
        padding-left: 20px;
      }
      pre {
        white-space: pre-wrap;
        margin: 8px 0 0;
        background: #020617;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.93rem;
      }
      th,
      td {
        border-bottom: 1px solid #374151;
        text-align: left;
        padding: 8px 6px;
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        background: #0f172a;
        border: 1px solid #475569;
        color: #cbd5e1;
        border-radius: 999px;
        padding: 3px 9px;
        font-size: 12px;
      }
      .history-item {
        margin-top: 8px;
        padding: 8px;
        border: 1px solid #374151;
        border-radius: 8px;
        background: #0f172a;
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: center;
      }
      footer {
        color: var(--muted);
        margin-top: 12px;
      }
      code {
        background: #020617;
        border: 1px solid #334155;
        border-radius: 5px;
        padding: 1px 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Cursor for Product Managers</h1>
      <p class="subtitle">
        Working local tool for PM discovery + vibe-coding handoff.
      </p>
      <p class="status" id="statusLine">
        Ready. Add signals and click "Analyze and recommend".
      </p>

      <div class="layout">
        <section class="panel">
          <h2>Inputs</h2>

          <label for="question">Question</label>
          <input
            id="question"
            type="text"
            value="What should we build next?"
            placeholder="What should we build next?"
          />

          <label for="interviews">Customer interviews (one signal per line)</label>
          <textarea id="interviews">
Users are confused in onboarding and fail to create their first project.
Enterprise team says setup needs better guided steps.
          </textarea>

          <label for="usage">Usage and product analytics signals</label>
          <textarea id="usage">
45% drop off before first successful project.
Teams using shared planning templates are retained 2.1x longer.
          </textarea>

          <label for="market">Market and strategy notes</label>
          <textarea id="market">
Competitors emphasize fast activation and guided templates.
Q1 objective is activation and team planning velocity.
          </textarea>

          <label for="uploads">Upload extra evidence (.txt, .md, .csv, .json)</label>
          <input id="uploads" type="file" multiple />

          <label for="mode">Vibe coding mode</label>
          <select id="mode">
            <option value="balanced">Balanced</option>
            <option value="safe">Safe / production-first</option>
            <option value="fast">Fast / prototype-first</option>
          </select>

          <div class="btn-row">
            <button class="btn-primary" id="analyzeBtn">
              Analyze and recommend
            </button>
            <button class="btn-secondary" id="exportJsonBtn">Export JSON</button>
            <button class="btn-secondary" id="exportMdBtn">Export Markdown</button>
            <button class="btn-secondary" id="clearHistoryBtn">
              Clear history
            </button>
          </div>
        </section>

        <section class="result-grid">
          <article class="card">
            <h3 id="topName">No recommendation generated</h3>
            <div class="small" id="topProblem">Run analysis to generate output.</div>
            <div class="chips" id="metaChips"></div>
            <div class="small" id="confidenceNote"></div>
          </article>

          <article class="card">
            <h3>Top recommendation evidence</h3>
            <ul id="evidenceList"></ul>
          </article>

          <article class="card">
            <h3>Opportunity ranking</h3>
            <table>
              <thead>
                <tr>
                  <th>Opportunity</th>
                  <th>Score</th>
                  <th>Evidence</th>
                  <th>Matched keywords</th>
                </tr>
              </thead>
              <tbody id="rankingTable"></tbody>
            </table>
          </article>

          <article class="card">
            <h3>Proposed product changes</h3>
            <div>
              <strong>UI</strong>
              <ul id="uiChanges"></ul>
            </div>
            <div>
              <strong>Data model</strong>
              <ul id="dataChanges"></ul>
            </div>
            <div>
              <strong>Workflow</strong>
              <ul id="workflowChanges"></ul>
            </div>
          </article>

          <article class="card">
            <h3>Coding-agent delivery plan</h3>
            <ul id="taskList"></ul>
          </article>

          <article class="card">
            <h3>Vibe coding prompt</h3>
            <pre id="promptOutput">Run analysis to generate prompt.</pre>
          </article>

          <article class="card">
            <h3>Saved runs</h3>
            <div class="small">Stored in browser localStorage.</div>
            <div id="historyList"></div>
          </article>
        </section>
      </div>

      <footer>
        Run locally: <code>python -m http.server 8000</code> and open
        <code>http://localhost:8000</code>.
      </footer>
    </div>

    <script>
      const HISTORY_KEY = "cursor_pm_runs_v2";
      let latestResult = null;
      let isAnalyzing = false;
      let analysisRunCount = 0;

      const opportunities = [
        {
          id: "guided-activation",
          name: "Guided Activation Journey",
          problem:
            "New users churn before first value because setup and first action are unclear.",
          keywords: [
            "onboarding",
            "activation",
            "first project",
            "first action",
            "setup",
            "drop off",
            "churn",
            "confused",
            "empty state",
          ],
          ui: [
            "Multi-step onboarding checklist anchored to first project completion",
            "Context-aware CTA on empty states",
          ],
          data: [
            "activation_funnel_events",
            "onboarding_step_completion",
            "time_to_first_project",
          ],
          workflow: [
            "New signup -> role selection -> guided setup -> first project completion",
          ],
        },
        {
          id: "collab-copilot",
          name: "Live Planning Collaboration Copilot",
          problem:
            "Teams lose momentum due to fragmented planning and weak collaboration loops.",
          keywords: [
            "team",
            "collaboration",
            "shared",
            "handoff",
            "planning",
            "review",
            "alignment",
            "comment",
            "async",
          ],
          ui: [
            "Shared planning workspace with live cursor presence",
            "Inline AI suggestions for each planning section",
          ],
          data: [
            "session_participants",
            "suggestion_acceptance_rate",
            "decision_cycle_time",
          ],
          workflow: [
            "Draft plan -> team review -> AI suggested edits -> approval -> task generation",
          ],
        },
        {
          id: "insight-graph",
          name: "Customer Signal Insight Graph",
          problem:
            "PMs cannot quickly connect qualitative feedback and usage metrics to decisions.",
          keywords: [
            "insight",
            "analytics",
            "usage",
            "metric",
            "dashboard",
            "feedback",
            "trend",
            "evidence",
            "data",
          ],
          ui: [
            "Opportunity board with evidence drill-down",
            "Trend chart for issue clusters and impact over time",
          ],
          data: [
            "signal_clusters",
            "opportunity_scores",
            "evidence_to_metric_links",
          ],
          workflow: [
            "Ingest signals -> cluster themes -> score opportunities -> decide sprint priority",
          ],
        },
        {
          id: "quality-guardrails",
          name: "Release Quality Guardrails",
          problem:
            "Reliability issues reduce trust and slow adoption in production teams.",
          keywords: [
            "bug",
            "error",
            "crash",
            "performance",
            "latency",
            "reliability",
            "quality",
            "failure",
            "incident",
          ],
          ui: [
            "Release risk panel for PM and engineering review",
            "Quality checklist integrated into launch workflow",
          ],
          data: [
            "defect_density",
            "incident_frequency",
            "release_risk_score",
          ],
          workflow: [
            "Spec complete -> quality gate checks -> launch decision -> post-release audit",
          ],
        },
      ];

      const STOP_WORDS = new Set([
        "about",
        "above",
        "after",
        "again",
        "also",
        "because",
        "before",
        "being",
        "between",
        "could",
        "every",
        "from",
        "have",
        "into",
        "just",
        "more",
        "most",
        "over",
        "that",
        "their",
        "there",
        "these",
        "this",
        "those",
        "very",
        "what",
        "when",
        "where",
        "which",
        "with",
        "would",
        "users",
        "user",
        "team",
        "teams",
      ]);

      const OPPORTUNITY_HINTS = {
        "guided-activation": [
          "onboard",
          "activate",
          "activation",
          "signup",
          "sign up",
          "first",
          "new user",
          "adoption",
          "setup",
          "tutorial",
        ],
        "collab-copilot": [
          "collabor",
          "handoff",
          "review",
          "alignment",
          "comment",
          "workflow",
          "shared",
          "approval",
          "planning",
        ],
        "insight-graph": [
          "insight",
          "metric",
          "analytics",
          "dashboard",
          "data",
          "evidence",
          "trend",
          "report",
          "funnel",
        ],
        "quality-guardrails": [
          "bug",
          "error",
          "crash",
          "latency",
          "incident",
          "reliability",
          "quality",
          "failure",
          "stability",
          "risk",
        ],
      };

      function status(message) {
        document.getElementById("statusLine").textContent = message;
      }

      function normalize(text) {
        return (text || "").toLowerCase();
      }

      function tokenize(text) {
        return normalize(text)
          .split(/[^a-z0-9]+/)
          .map((token) => token.trim())
          .filter((token) => token.length >= 3 && !STOP_WORDS.has(token));
      }

      function toSnakeCase(text) {
        return normalize(text).replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
      }

      function toTitleCase(text) {
        return (text || "")
          .split(/\s+/)
          .map((word) => (word ? word[0].toUpperCase() + word.slice(1).toLowerCase() : ""))
          .join(" ")
          .trim();
      }

      function summarizeSignal(signal, maxLength) {
        const cleaned = String(signal || "").replace(/^[^:]+:\s*/, "").trim();
        if (cleaned.length <= maxLength) return cleaned;
        return cleaned.slice(0, maxLength - 1).trim() + "…";
      }

      function extractThemes(signals, limit) {
        const counts = new Map();
        signals.forEach((signal) => {
          tokenize(signal).forEach((token) => {
            counts.set(token, (counts.get(token) || 0) + 1);
          });
        });
        return Array.from(counts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, limit)
          .map(([token]) => token);
      }

      function splitIntoSignals(text, prefix) {
        return (text || "")
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => (prefix ? prefix + ": " + line : line));
      }

      function gatherJsonStrings(node, bucket) {
        if (typeof node === "string") {
          const trimmed = node.trim();
          if (trimmed) bucket.push(trimmed);
          return;
        }
        if (typeof node === "number" || typeof node === "boolean") {
          bucket.push(String(node));
          return;
        }
        if (Array.isArray(node)) {
          node.forEach((item) => gatherJsonStrings(item, bucket));
          return;
        }
        if (node && typeof node === "object") {
          Object.values(node).forEach((value) => gatherJsonStrings(value, bucket));
        }
      }

      function parseCsvText(text) {
        const lines = text.split(/\r?\n/).filter(Boolean);
        if (!lines.length) return [];
        const header = lines[0].split(",").map((x) => x.trim());
        return lines.slice(1).map((line) => {
          const cols = line.split(",").map((x) => x.trim());
          return cols
            .map((value, idx) => (header[idx] ? header[idx] + "=" + value : value))
            .join(" | ");
        });
      }

      async function readFileAsText(file) {
        if (file && typeof file.text === "function") {
          return file.text();
        }
        if (file && typeof file.arrayBuffer === "function") {
          const buffer = await file.arrayBuffer();
          return new TextDecoder().decode(buffer);
        }
        if (typeof FileReader !== "undefined") {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            const timeout = setTimeout(
              () => reject(new Error("Timed out reading uploaded file.")),
              5000,
            );
            reader.onload = () => {
              clearTimeout(timeout);
              resolve(String(reader.result || ""));
            };
            reader.onerror = () => {
              clearTimeout(timeout);
              reject(reader.error || new Error("Failed to read uploaded file."));
            };
            reader.readAsText(file);
          });
        }
        throw new Error("File APIs are not supported in this browser.");
      }

      async function readFileSignals(file) {
        const name = file.name.toLowerCase();
        const raw = await readFileAsText(file);
        if (name.endsWith(".json")) {
          try {
            const parsed = JSON.parse(raw);
            const extracted = [];
            gatherJsonStrings(parsed, extracted);
            return extracted.map((line) => file.name + ": " + line);
          } catch (error) {
            return [file.name + ": invalid JSON (" + error.message + ")"];
          }
        }
        if (name.endsWith(".csv")) {
          return parseCsvText(raw).map((line) => file.name + ": " + line);
        }
        return splitIntoSignals(raw, file.name);
      }

      function signalWeight(signal) {
        let weight = 1;
        if (/\d+%/.test(signal)) weight += 1;
        if (/\b(drop|churn|block|fail|slow|urgent|incident|error)\b/i.test(signal)) {
          weight += 1;
        }
        return weight;
      }

      function scoreOpportunity(opp, signals) {
        let score = 0;
        const evidence = [];
        const matched = new Set();
        const hints = OPPORTUNITY_HINTS[opp.id] || [];

        signals.forEach((signal) => {
          const line = normalize(signal);
          const lineTokens = new Set(tokenize(line));
          const directHits = opp.keywords.filter((kw) => line.includes(kw.toLowerCase()));
          const hintHits = hints.filter((hint) => line.includes(hint));
          const tokenHits = opp.keywords.filter((kw) =>
            tokenize(kw).some((token) => lineTokens.has(token)),
          );
          const hits = Array.from(new Set([...directHits, ...hintHits, ...tokenHits]));
          if (!hits.length) return;
          hits.forEach((kw) => matched.add(kw));
          const weighted = hits.length * 3 + signalWeight(line);
          score += weighted;
          evidence.push({
            text: signal,
            keywords: hits,
            weighted,
          });
        });

        return {
          ...opp,
          ui: [...opp.ui],
          data: [...opp.data],
          workflow: [...opp.workflow],
          score,
          evidence,
          matchedKeywords: Array.from(matched),
        };
      }

      function buildEvidenceFallback(signals, themes, limit) {
        const fallbackKeywords = themes.length ? themes : ["signal"];
        return signals.slice(0, limit).map((signal) => ({
          text: signal,
          keywords: fallbackKeywords.slice(0, 3),
          weighted: 1,
        }));
      }

      function enrichTopOpportunity(base, signals, themes) {
        const dynamicThemes = themes.length ? themes : ["workflow", "adoption"];
        const themeLabel = dynamicThemes.slice(0, 2).map(toTitleCase).join(" + ");
        const evidence = base.evidence.length
          ? base.evidence
          : buildEvidenceFallback(signals, dynamicThemes, 6);
        const mainSummary = summarizeSignal(signals[0] || "", 120);
        const supportingSummary = summarizeSignal(signals[1] || "", 120);

        const ui = [...base.ui];
        const data = [...base.data];
        const workflow = [...base.workflow];
        if (dynamicThemes[0]) {
          ui.push(
            'Focused UX guidance for "' +
              dynamicThemes[0] +
              '" signals to reduce user friction.',
          );
          data.push("theme_" + toSnakeCase(dynamicThemes[0]) + "_impact_events");
        }
        workflow.push("Review weekly signal deltas and re-score this opportunity.");

        return {
          ...base,
          name: themeLabel ? base.name + " for " + themeLabel : base.name,
          problem:
            "Based on " +
            signals.length +
            " signals, the strongest pain points are: " +
            mainSummary +
            (supportingSummary ? " | " + supportingSummary : ""),
          ui,
          data,
          workflow,
          evidence,
          score: Math.max(base.score, 4 + dynamicThemes.length * 2),
          matchedKeywords: Array.from(
            new Set([...(base.matchedKeywords || []), ...dynamicThemes]),
          ),
        };
      }

      function buildSignalDrivenOpportunity(signals, themes) {
        const dynamicThemes = themes.length ? themes : ["activation", "clarity", "quality"];
        const label = dynamicThemes.slice(0, 2).map(toTitleCase).join(" + ");
        const mainTheme = dynamicThemes[0];
        return {
          id: "signal-driven-opportunity",
          name: "Signal-Driven Opportunity: " + label,
          problem:
            "Input data shows repeated friction around " +
            dynamicThemes.slice(0, 3).join(", ") +
            ". Build a focused feature to address this evidence directly.",
          keywords: [...dynamicThemes],
          ui: [
            "Introduce guided interactions around " + mainTheme + ".",
            "Show in-product context for affected users and steps.",
          ],
          data: [
            "signal_driven_opportunity_score",
            "theme_" + toSnakeCase(mainTheme) + "_events",
            "time_to_resolution",
          ],
          workflow: [
            "Ingest fresh signals -> ship targeted iteration -> measure outcome impact",
          ],
          score: 6 + dynamicThemes.length * 2,
          evidence: buildEvidenceFallback(signals, dynamicThemes, 8),
          matchedKeywords: dynamicThemes,
        };
      }

      function ensureEvidenceCoverage(evidence, signals, themes) {
        const next = [...(evidence || [])];
        const seen = new Set(next.map((item) => item.text));
        const fallbackKeywords = themes.length ? themes.slice(0, 3) : ["signal"];
        const uploaded = signals.filter((signal) => /\.[a-z0-9]+:\s/i.test(signal));
        const ordered = [...uploaded, ...signals];

        ordered.forEach((signal) => {
          if (next.length >= 10) return;
          if (seen.has(signal)) return;
          next.push({
            text: signal,
            keywords: fallbackKeywords,
            weighted: 1,
          });
          seen.add(signal);
        });
        return next;
      }

      function buildTasks(name, mode) {
        const modeTask =
          mode === "fast"
            ? "Ship prototype in one short loop, then refine from feedback."
            : mode === "safe"
              ? "Include full validation + edge-case handling before release."
              : "Use iterative slices with quick demo checkpoints.";
        return [
          "Draft product spec and acceptance criteria for " + name + ".",
          "Implement UI surface and interaction states.",
          "Implement data model/events and analytics instrumentation.",
          "Implement workflow orchestration and permissions.",
          "Add tests + rollout checklist + telemetry validation.",
          modeTask,
        ];
      }

      function clampNumber(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function getConfidenceLabel(score) {
        if (score >= 82) return "High";
        if (score >= 68) return "Medium";
        return "Low";
      }

      function computeConfidence(top, ranking, signals, themes, matchedEvidence) {
        const second = ranking[1];
        const evidence = matchedEvidence || [];
        const signalVolume = clampNumber(signals.length / 14, 0, 1);
        const weightedEvidence = evidence.reduce(
          (sum, item) => sum + Math.max(0, Number(item.weighted) || 0),
          0,
        );
        const evidenceDensity = signals.length
          ? clampNumber(
              evidence.filter((item) => (Number(item.weighted) || 0) > 1).length /
                signals.length,
              0,
              1,
            )
          : 0;
        const evidenceStrength = signals.length
          ? clampNumber(
              (weightedEvidence / Math.max(1, signals.length * 6)) * 0.7 +
                evidenceDensity * 0.3,
              0,
              1,
            )
          : 0;
        const separation = second
          ? clampNumber(
              ((top.score - second.score) / Math.max(1, top.score)) *
                clampNumber(top.score / 35, 0, 1),
              0,
              1,
            )
          : clampNumber(top.score / 40, 0, 1);
        const specificity = clampNumber(top.matchedKeywords.length / 8, 0, 1);
        const themeStrength = clampNumber((themes || []).length / 5, 0, 1);

        const blended =
          signalVolume * 0.2 +
          evidenceStrength * 0.4 +
          separation * 0.2 +
          specificity * 0.15 +
          themeStrength * 0.05;
        const score = clampNumber(Math.round(18 + blended * 77), 18, 95);

        const reasons = [
          "Evidence strength " + Math.round(evidenceStrength * 100) + "%",
          "Top-vs-next separation " + Math.round(separation * 100) + "%",
          "Signal volume " + signals.length,
        ];

        return {
          score,
          label: getConfidenceLabel(score),
          reasons,
          metrics: {
            signalVolume,
            evidenceStrength,
            separation,
            specificity,
            themeStrength,
          },
        };
      }

      function buildPrompt(result, mode, question) {
        return [
          "Question: " + question,
          "You are implementing: " + result.name,
          "Mode: " + mode,
          "Problem: " + result.problem,
          "UI changes: " + result.ui.join("; "),
          "Data model changes: " + result.data.join("; "),
          "Workflow changes: " + result.workflow.join("; "),
          "Evidence:",
          ...result.evidence.slice(0, 6).map((e) => "- " + e.text),
          "Tasks:",
          ...result.tasks.map((t) => "- " + t),
          "Return: code diff, tests, rollout plan, and risks.",
        ].join("\n");
      }

      function renderList(id, items) {
        document.getElementById(id).innerHTML = (items || [])
          .map((item) => "<li>" + item + "</li>")
          .join("");
      }

      function renderRanking(rows) {
        document.getElementById("rankingTable").innerHTML = rows
          .map((row) => {
            return (
              "<tr><td>" +
              row.name +
              "</td><td>" +
              row.score +
              "</td><td>" +
              row.evidence.length +
              "</td><td>" +
              (row.matchedKeywords.slice(0, 6).join(", ") || "-") +
              "</td></tr>"
            );
          })
          .join("");
      }

      function downloadText(filename, text, type) {
        const blob = new Blob([text], { type: type || "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function getHistory() {
        try {
          const raw = localStorage.getItem(HISTORY_KEY);
          const parsed = raw ? JSON.parse(raw) : [];
          return Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          return [];
        }
      }

      function saveHistory(entry) {
        const history = getHistory();
        const next = [entry, ...history].slice(0, 10);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(next));
        renderHistory();
      }

      function renderHistory() {
        const history = getHistory();
        const container = document.getElementById("historyList");
        if (!history.length) {
          container.innerHTML = '<div class="small">No saved runs yet.</div>';
          return;
        }
        container.innerHTML = history
          .map((item, idx) => {
            return (
              '<div class="history-item">' +
              "<span>" +
              item.timestamp +
              " - " +
              item.topName +
              "</span>" +
              '<button class="btn-secondary" data-load="' +
              idx +
              '">Load</button>' +
              "</div>"
            );
          })
          .join("");
      }

      function loadHistory(index) {
        const history = getHistory();
        const item = history[index];
        if (!item) return;
        latestResult = item.payload;
        renderResult(latestResult);
        status("Loaded saved run from history.");
      }

      function renderResult(payload) {
        const top = payload.top;
        document.getElementById("topName").textContent = top.name;
        document.getElementById("topProblem").textContent = top.problem;
        const themeChip = payload.themes && payload.themes.length
          ? '<span class="chip">Themes: ' + payload.themes.slice(0, 3).join(", ") + "</span>"
          : "";
        document.getElementById("metaChips").innerHTML =
          '<span class="chip">Confidence: ' +
          payload.confidence +
          "% (" +
          (payload.confidenceLabel || "n/a") +
          ")</span>" +
          '<span class="chip">Signals: ' +
          payload.signalCount +
          "</span>" +
          '<span class="chip">Mode: ' +
          payload.mode +
          "</span>" +
          themeChip;
        document.getElementById("confidenceNote").textContent =
          payload.confidenceReasons && payload.confidenceReasons.length
            ? "Confidence basis: " + payload.confidenceReasons.join(" | ")
            : "";

        renderList(
          "evidenceList",
          top.evidence.length
            ? top.evidence.slice(0, 8).map((ev) => ev.text + " [" + ev.keywords.join(", ") + "]")
            : ["No evidence matched. Add more specific signals."],
        );
        renderRanking(payload.ranking);
        renderList("uiChanges", top.ui);
        renderList("dataChanges", top.data);
        renderList("workflowChanges", top.workflow);
        renderList("taskList", top.tasks);
        document.getElementById("promptOutput").textContent = payload.prompt;
      }

      function buildMarkdown(payload) {
        const top = payload.top;
        return [
          "# Cursor PM Brief",
          "",
          "- Timestamp: " + payload.timestamp,
          "- Question: " + payload.question,
          "- Mode: " + payload.mode,
          "- Confidence: " + payload.confidence + "% (" + (payload.confidenceLabel || "n/a") + ")",
          "- Confidence basis: " + (payload.confidenceReasons && payload.confidenceReasons.length ? payload.confidenceReasons.join(", ") : "n/a"),
          "- Themes: " + (payload.themes && payload.themes.length ? payload.themes.join(", ") : "n/a"),
          "",
          "## Recommended Feature",
          top.name,
          "",
          "## Problem",
          top.problem,
          "",
          "## Evidence",
          ...top.evidence.slice(0, 10).map((e) => "- " + e.text),
          "",
          "## UI Changes",
          ...top.ui.map((x) => "- " + x),
          "",
          "## Data Changes",
          ...top.data.map((x) => "- " + x),
          "",
          "## Workflow Changes",
          ...top.workflow.map((x) => "- " + x),
          "",
          "## Delivery Tasks",
          ...top.tasks.map((x) => "- " + x),
          "",
          "## Vibe Coding Prompt",
          "```",
          payload.prompt,
          "```",
        ].join("\n");
      }

      async function analyze() {
        if (isAnalyzing) {
          status("Still processing previous analysis...");
          return;
        }

        const analyzeButton = document.getElementById("analyzeBtn");
        const initialButtonText = analyzeButton.textContent;
        isAnalyzing = true;
        analyzeButton.disabled = true;
        analyzeButton.textContent = "Analyzing...";

        try {
          const question =
            document.getElementById("question").value.trim() || "What should we build next?";
          const mode = document.getElementById("mode").value;
          const interviews = splitIntoSignals(
            document.getElementById("interviews").value,
            "interview",
          );
          const usage = splitIntoSignals(document.getElementById("usage").value, "usage");
          const market = splitIntoSignals(document.getElementById("market").value, "market");
          const fileInput = document.getElementById("uploads");
          const files = Array.from(fileInput.files || []);

          status("Processing signals...");
          const uploadedSignals = [];
          for (const file of files) {
            const fileSignals = await readFileSignals(file);
            uploadedSignals.push(...fileSignals);
          }
          const signals = [...interviews, ...usage, ...market, ...uploadedSignals];
          if (!signals.length) {
            status("No signals found. Add text or upload files.");
            return;
          }

          const themes = extractThemes(signals, 5);
          let ranking = opportunities
            .map((opp) => scoreOpportunity(opp, signals))
            .sort((a, b) => b.score - a.score);

          let top = ranking[0];
          if (!top || top.score <= 0) {
            top = buildSignalDrivenOpportunity(signals, themes);
            ranking = [top, ...ranking];
          } else {
            top = enrichTopOpportunity(top, signals, themes);
            ranking = [top, ...ranking.slice(1)];
          }

          const matchedEvidence = [...top.evidence];
          top.evidence = ensureEvidenceCoverage(top.evidence, signals, themes);
          top.tasks = buildTasks(top.name, mode);
          const confidence = computeConfidence(top, ranking, signals, themes, matchedEvidence);
          const timestamp = new Date().toLocaleString();
          const prompt = buildPrompt(top, mode, question);

          const payload = {
            timestamp,
            question,
            mode,
            signalCount: signals.length,
            confidence: confidence.score,
            confidenceLabel: confidence.label,
            confidenceReasons: confidence.reasons,
            themes,
            top,
            ranking: ranking.slice(0, 6).map((item) => ({
              name: item.name,
              score: item.score,
              evidence: item.evidence,
              matchedKeywords: item.matchedKeywords,
            })),
            prompt,
          };

          latestResult = payload;
          renderResult(payload);
          saveHistory({
            timestamp,
            topName: top.name,
            payload,
          });
          analysisRunCount += 1;
          status(
            "Recommendation generated from " +
              signals.length +
              " signals (run #" +
              analysisRunCount +
              " at " +
              new Date().toLocaleTimeString() +
              ").",
          );
        } finally {
          isAnalyzing = false;
          analyzeButton.disabled = false;
          analyzeButton.textContent = initialButtonText;
        }
      }

      function debounce(fn, wait) {
        let timer = null;
        return (...args) => {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => fn(...args), wait);
        };
      }

      const scheduleAnalyze = debounce(() => {
        analyze().catch((error) => {
          status("Failed to analyze: " + error.message);
        });
      }, 450);

      ["question", "interviews", "usage", "market"].forEach((id) => {
        document.getElementById(id).addEventListener("input", () => {
          status("Input updated. Re-analyzing...");
          scheduleAnalyze();
        });
      });
      document.getElementById("mode").addEventListener("change", () => {
        status("Mode changed. Re-analyzing...");
        scheduleAnalyze();
      });
      document.getElementById("uploads").addEventListener("change", () => {
        status("Files added. Re-analyzing...");
        analyze().catch((error) => {
          status("Failed to analyze: " + error.message);
        });
      });

      document.getElementById("analyzeBtn").addEventListener("click", () => {
        analyze().catch((error) => {
          status("Failed to analyze: " + error.message);
        });
      });

      document.getElementById("exportJsonBtn").addEventListener("click", () => {
        if (!latestResult) {
          status("Generate a recommendation before exporting.");
          return;
        }
        downloadText(
          "cursor-pm-brief.json",
          JSON.stringify(latestResult, null, 2),
          "application/json;charset=utf-8",
        );
        status("Exported JSON brief.");
      });

      document.getElementById("exportMdBtn").addEventListener("click", () => {
        if (!latestResult) {
          status("Generate a recommendation before exporting.");
          return;
        }
        downloadText(
          "cursor-pm-brief.md",
          buildMarkdown(latestResult),
          "text/markdown;charset=utf-8",
        );
        status("Exported Markdown brief.");
      });

      document.getElementById("historyList").addEventListener("click", (event) => {
        const loadIndex = event.target.getAttribute("data-load");
        if (loadIndex === null) return;
        loadHistory(Number(loadIndex));
      });

      document.getElementById("clearHistoryBtn").addEventListener("click", () => {
        localStorage.removeItem(HISTORY_KEY);
        renderHistory();
        status("Cleared saved history.");
      });

      renderHistory();
      analyze().catch((error) => {
        status("Failed to run initial analysis: " + error.message);
      });
    </script>
  </body>
</html>
