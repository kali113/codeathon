<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Cursor for Product Managers — Working Tool</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #111827;
        --panel-2: #1f2937;
        --line: #334155;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #22d3ee;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, Segoe UI, Arial, Helvetica, sans-serif;
        background: linear-gradient(180deg, #020617 0%, #0b1220 100%);
        color: var(--text);
      }
      .wrap {
        max-width: 1320px;
        margin: 0 auto;
        padding: 22px 16px 32px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 2rem;
      }
      .subtitle {
        margin: 0 0 14px;
        color: var(--muted);
      }
      .status {
        margin: 0 0 18px;
        color: var(--accent);
        font-size: 0.95rem;
      }
      .layout {
        display: grid;
        gap: 16px;
      }
      @media (min-width: 1100px) {
        .layout {
          grid-template-columns: 420px 1fr;
        }
      }
      .panel {
        background: rgba(17, 24, 39, 0.92);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 14px;
      }
      .panel h2 {
        margin: 0 0 10px;
        font-size: 1.05rem;
      }
      label {
        display: block;
        margin: 10px 0 6px;
        font-weight: 600;
      }
      textarea,
      input[type="text"],
      select,
      input[type="file"] {
        width: 100%;
        color: var(--text);
        background: #0f172a;
        border: 1px solid #475569;
        border-radius: 8px;
        padding: 10px;
      }
      textarea {
        min-height: 88px;
        resize: vertical;
      }
      .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }
      button {
        border: 0;
        border-radius: 8px;
        padding: 9px 12px;
        font-weight: 700;
        cursor: pointer;
      }
      .btn-primary {
        background: var(--accent);
        color: #06232b;
      }
      .btn-secondary {
        background: #0f172a;
        color: var(--text);
        border: 1px solid #475569;
      }
      .result-grid {
        display: grid;
        gap: 12px;
      }
      .card {
        background: rgba(31, 41, 55, 0.9);
        border: 1px solid #475569;
        border-radius: 10px;
        padding: 12px;
      }
      .card h3 {
        margin: 0 0 8px;
        color: var(--accent);
      }
      .small {
        color: var(--muted);
        font-size: 0.92rem;
      }
      ul {
        margin: 8px 0 0;
        padding-left: 20px;
      }
      pre {
        white-space: pre-wrap;
        margin: 8px 0 0;
        background: #020617;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.93rem;
      }
      th,
      td {
        border-bottom: 1px solid #374151;
        text-align: left;
        padding: 8px 6px;
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .chip {
        background: #0f172a;
        border: 1px solid #475569;
        color: #cbd5e1;
        border-radius: 999px;
        padding: 3px 9px;
        font-size: 12px;
      }
      .history-item {
        margin-top: 8px;
        padding: 8px;
        border: 1px solid #374151;
        border-radius: 8px;
        background: #0f172a;
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: center;
      }
      .table-scroll {
        max-height: 320px;
        overflow: auto;
        border: 1px solid #334155;
        border-radius: 8px;
      }
      .line-text {
        max-width: 420px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      footer {
        color: var(--muted);
        margin-top: 12px;
      }
      code {
        background: #020617;
        border: 1px solid #334155;
        border-radius: 5px;
        padding: 1px 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Cursor for Product Managers</h1>
      <p class="subtitle">
        Working local tool for PM discovery + vibe-coding handoff.
      </p>
      <p class="status" id="statusLine">
        Ready. Add signals and click "Analyze and recommend".
      </p>

      <div class="layout">
        <section class="panel">
          <h2>Inputs</h2>

          <label for="question">Question</label>
          <input
            id="question"
            type="text"
            value="What should we build next?"
            placeholder="What should we build next?"
          />

          <label for="interviews">Customer interviews (one signal per line)</label>
          <textarea id="interviews">
Users are confused in onboarding and fail to create their first project.
Enterprise team says setup needs better guided steps.
          </textarea>

          <label for="usage">Usage and product analytics signals</label>
          <textarea id="usage">
45% drop off before first successful project.
Teams using shared planning templates are retained 2.1x longer.
          </textarea>

          <label for="market">Market and strategy notes</label>
          <textarea id="market">
Competitors emphasize fast activation and guided templates.
Q1 objective is activation and team planning velocity.
          </textarea>

          <label for="uploads">Upload extra evidence (.txt, .md, .csv, .json)</label>
          <input id="uploads" type="file" multiple />

          <label for="mode">Vibe coding mode</label>
          <select id="mode">
            <option value="balanced">Balanced</option>
            <option value="safe">Safe / production-first</option>
            <option value="fast">Fast / prototype-first</option>
          </select>

          <div class="btn-row">
            <button class="btn-primary" id="analyzeBtn">
              Analyze and recommend
            </button>
            <button class="btn-secondary" id="exportJsonBtn">Export JSON</button>
            <button class="btn-secondary" id="exportMdBtn">Export Markdown</button>
            <button class="btn-secondary" id="clearHistoryBtn">
              Clear history
            </button>
          </div>
        </section>

        <section class="result-grid">
          <article class="card">
            <h3 id="topName">No recommendation generated</h3>
            <div class="small" id="topProblem">Run analysis to generate output.</div>
            <div class="chips" id="metaChips"></div>
            <div class="small" id="confidenceNote"></div>
            <div class="small" id="actionNote">Last action: none</div>
          </article>

          <article class="card">
            <h3>Top recommendation evidence</h3>
            <ul id="evidenceList"></ul>
          </article>

          <article class="card">
            <h3>Opportunity ranking</h3>
            <table>
              <thead>
                <tr>
                  <th>Opportunity</th>
                  <th>Score</th>
                  <th>Evidence</th>
                  <th>Matched keywords</th>
                </tr>
              </thead>
              <tbody id="rankingTable"></tbody>
            </table>
          </article>

          <article class="card">
            <h3>Line-by-line response (all signals)</h3>
            <div class="small" id="lineSummary">No lines processed yet.</div>
            <div class="table-scroll">
              <table>
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Signal line</th>
                    <th>Top match</th>
                    <th>Impact</th>
                    <th>Keywords</th>
                  </tr>
                </thead>
                <tbody id="signalTable"></tbody>
              </table>
            </div>
          </article>

          <article class="card">
            <h3>Proposed product changes</h3>
            <div>
              <strong>UI</strong>
              <ul id="uiChanges"></ul>
            </div>
            <div>
              <strong>Data model</strong>
              <ul id="dataChanges"></ul>
            </div>
            <div>
              <strong>Workflow</strong>
              <ul id="workflowChanges"></ul>
            </div>
          </article>

          <article class="card">
            <h3>Coding-agent delivery plan</h3>
            <ul id="taskList"></ul>
          </article>

          <article class="card">
            <h3>Vibe coding prompt</h3>
            <pre id="promptOutput">Run analysis to generate prompt.</pre>
          </article>

          <article class="card">
            <h3>Saved runs</h3>
            <div class="small">Stored in browser localStorage.</div>
            <div id="historyList"></div>
          </article>
        </section>
      </div>

      <footer>
        Run locally: <code>python -m http.server 8000</code> and open
        <code>http://localhost:8000</code>.
      </footer>
    </div>

    <script>
      const HISTORY_KEY = "cursor_pm_runs_v2";
      let latestResult = null;
      let isAnalyzing = false;
      let analysisRunCount = 0;
      let queuedAnalyzeSource = null;
      let actionCount = 0;

      const opportunities = [
        {
          id: "guided-activation",
          name: "Guided Activation Journey",
          problem:
            "New users churn before first value because setup and first action are unclear.",
          keywords: [
            "onboarding",
            "activation",
            "first project",
            "first action",
            "setup",
            "drop off",
            "churn",
            "confused",
            "empty state",
          ],
          ui: [
            "Multi-step onboarding checklist anchored to first project completion",
            "Context-aware CTA on empty states",
          ],
          data: [
            "activation_funnel_events",
            "onboarding_step_completion",
            "time_to_first_project",
          ],
          workflow: [
            "New signup -> role selection -> guided setup -> first project completion",
          ],
        },
        {
          id: "collab-copilot",
          name: "Live Planning Collaboration Copilot",
          problem:
            "Teams lose momentum due to fragmented planning and weak collaboration loops.",
          keywords: [
            "team",
            "collaboration",
            "shared",
            "handoff",
            "planning",
            "review",
            "alignment",
            "comment",
            "async",
          ],
          ui: [
            "Shared planning workspace with live cursor presence",
            "Inline AI suggestions for each planning section",
          ],
          data: [
            "session_participants",
            "suggestion_acceptance_rate",
            "decision_cycle_time",
          ],
          workflow: [
            "Draft plan -> team review -> AI suggested edits -> approval -> task generation",
          ],
        },
        {
          id: "insight-graph",
          name: "Customer Signal Insight Graph",
          problem:
            "PMs cannot quickly connect qualitative feedback and usage metrics to decisions.",
          keywords: [
            "insight",
            "analytics",
            "usage",
            "metric",
            "dashboard",
            "feedback",
            "trend",
            "evidence",
            "data",
          ],
          ui: [
            "Opportunity board with evidence drill-down",
            "Trend chart for issue clusters and impact over time",
          ],
          data: [
            "signal_clusters",
            "opportunity_scores",
            "evidence_to_metric_links",
          ],
          workflow: [
            "Ingest signals -> cluster themes -> score opportunities -> decide sprint priority",
          ],
        },
        {
          id: "quality-guardrails",
          name: "Release Quality Guardrails",
          problem:
            "Reliability issues reduce trust and slow adoption in production teams.",
          keywords: [
            "bug",
            "error",
            "crash",
            "performance",
            "latency",
            "reliability",
            "quality",
            "failure",
            "incident",
          ],
          ui: [
            "Release risk panel for PM and engineering review",
            "Quality checklist integrated into launch workflow",
          ],
          data: [
            "defect_density",
            "incident_frequency",
            "release_risk_score",
          ],
          workflow: [
            "Spec complete -> quality gate checks -> launch decision -> post-release audit",
          ],
        },
      ];

      const STOP_WORDS = new Set([
        "about",
        "above",
        "after",
        "again",
        "also",
        "because",
        "before",
        "being",
        "between",
        "could",
        "every",
        "from",
        "have",
        "into",
        "just",
        "more",
        "most",
        "over",
        "that",
        "their",
        "there",
        "these",
        "this",
        "those",
        "very",
        "what",
        "when",
        "where",
        "which",
        "with",
        "would",
        "users",
        "user",
        "team",
        "teams",
      ]);

      const OPPORTUNITY_HINTS = {
        "guided-activation": [
          "onboard",
          "activate",
          "activation",
          "signup",
          "sign up",
          "first",
          "new user",
          "adoption",
          "setup",
          "tutorial",
        ],
        "collab-copilot": [
          "collabor",
          "handoff",
          "review",
          "alignment",
          "comment",
          "workflow",
          "shared",
          "approval",
          "planning",
        ],
        "insight-graph": [
          "insight",
          "metric",
          "analytics",
          "dashboard",
          "data",
          "evidence",
          "trend",
          "report",
          "funnel",
        ],
        "quality-guardrails": [
          "bug",
          "error",
          "crash",
          "latency",
          "incident",
          "reliability",
          "quality",
          "failure",
          "stability",
          "risk",
        ],
      };

      function status(message) {
        document.getElementById("statusLine").textContent = message;
      }

      function recordAction(action, detail) {
        actionCount += 1;
        const detailText = detail ? " — " + detail : "";
        document.getElementById("actionNote").textContent =
          "Last action #" + actionCount + ": " + action + detailText;
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function normalize(text) {
        return (text || "").toLowerCase();
      }

      function tokenize(text) {
        return normalize(text)
          .split(/[^a-z0-9]+/)
          .map((token) => token.trim())
          .filter((token) => token.length >= 3 && !STOP_WORDS.has(token));
      }

      function toSnakeCase(text) {
        return normalize(text).replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
      }

      function toTitleCase(text) {
        return (text || "")
          .split(/\s+/)
          .map((word) => (word ? word[0].toUpperCase() + word.slice(1).toLowerCase() : ""))
          .join(" ")
          .trim();
      }

      function summarizeSignal(signal, maxLength) {
        const cleaned = String(signal || "").replace(/^[^:]+:\s*/, "").trim();
        if (cleaned.length <= maxLength) return cleaned;
        return cleaned.slice(0, maxLength - 1).trim() + "…";
      }

      function extractThemes(signals, limit) {
        const counts = new Map();
        signals.forEach((signal) => {
          tokenize(signal).forEach((token) => {
            counts.set(token, (counts.get(token) || 0) + 1);
          });
        });
        return Array.from(counts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, limit)
          .map(([token]) => token);
      }

      function splitIntoSignals(text, prefix) {
        return (text || "")
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => (prefix ? prefix + ": " + line : line));
      }

      function gatherJsonStrings(node, bucket) {
        if (typeof node === "string") {
          const trimmed = node.trim();
          if (trimmed) bucket.push(trimmed);
          return;
        }
        if (typeof node === "number" || typeof node === "boolean") {
          bucket.push(String(node));
          return;
        }
        if (Array.isArray(node)) {
          node.forEach((item) => gatherJsonStrings(item, bucket));
          return;
        }
        if (node && typeof node === "object") {
          Object.values(node).forEach((value) => gatherJsonStrings(value, bucket));
        }
      }

      function parseCsvText(text) {
        const lines = text.split(/\r?\n/).filter(Boolean);
        if (!lines.length) return [];
        const header = lines[0].split(",").map((x) => x.trim());
        return lines.slice(1).map((line) => {
          const cols = line.split(",").map((x) => x.trim());
          return cols
            .map((value, idx) => (header[idx] ? header[idx] + "=" + value : value))
            .join(" | ");
        });
      }

      async function readFileAsText(file) {
        if (file && typeof file.text === "function") {
          return file.text();
        }
        if (file && typeof file.arrayBuffer === "function") {
          const buffer = await file.arrayBuffer();
          return new TextDecoder().decode(buffer);
        }
        if (typeof FileReader !== "undefined") {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            const timeout = setTimeout(
              () => reject(new Error("Timed out reading uploaded file.")),
              5000,
            );
            reader.onload = () => {
              clearTimeout(timeout);
              resolve(String(reader.result || ""));
            };
            reader.onerror = () => {
              clearTimeout(timeout);
              reject(reader.error || new Error("Failed to read uploaded file."));
            };
            reader.readAsText(file);
          });
        }
        throw new Error("File APIs are not supported in this browser.");
      }

      async function readFileSignals(file) {
        const name = file.name.toLowerCase();
        const raw = await readFileAsText(file);
        if (name.endsWith(".json")) {
          try {
            const parsed = JSON.parse(raw);
            const extracted = [];
            gatherJsonStrings(parsed, extracted);
            return extracted.map((line) => file.name + ": " + line);
          } catch (error) {
            return [file.name + ": invalid JSON (" + error.message + ")"];
          }
        }
        if (name.endsWith(".csv")) {
          return parseCsvText(raw).map((line) => file.name + ": " + line);
        }
        return splitIntoSignals(raw, file.name);
      }

      function signalWeight(signal) {
        let weight = 1;
        if (/\d+%/.test(signal)) weight += 1;
        if (/\b(drop|churn|block|fail|slow|urgent|incident|error)\b/i.test(signal)) {
          weight += 1;
        }
        return weight;
      }

      function getHitsForOpportunity(signal, opp) {
        const line = normalize(signal);
        const lineTokens = new Set(tokenize(line));
        const hints = OPPORTUNITY_HINTS[opp && opp.id] || [];
        const keywords = Array.isArray(opp && opp.keywords)
          ? opp.keywords
          : Array.isArray(opp && opp.matchedKeywords)
            ? opp.matchedKeywords
            : [];
        const directHits = keywords.filter((kw) => line.includes(String(kw).toLowerCase()));
        const hintHits = hints.filter((hint) => line.includes(hint));
        const tokenHits = keywords.filter((kw) =>
          tokenize(kw).some((token) => lineTokens.has(token)),
        );
        return Array.from(new Set([...directHits, ...hintHits, ...tokenHits]));
      }

      function scoreOpportunity(opp, signals) {
        let score = 0;
        const evidence = [];
        const matched = new Set();

        signals.forEach((signal) => {
          const line = normalize(signal);
          const hits = getHitsForOpportunity(line, opp);
          if (!hits.length) return;
          hits.forEach((kw) => matched.add(kw));
          const weighted = hits.length * 3 + signalWeight(line);
          score += weighted;
          evidence.push({
            text: signal,
            keywords: hits,
            weighted,
          });
        });

        return {
          ...opp,
          ui: [...opp.ui],
          data: [...opp.data],
          workflow: [...opp.workflow],
          score,
          evidence,
          matchedKeywords: Array.from(matched),
        };
      }

      function buildEvidenceFallback(signals, themes, limit) {
        const fallbackKeywords = themes.length ? themes : ["signal"];
        return signals.slice(0, limit).map((signal) => ({
          text: signal,
          keywords: fallbackKeywords.slice(0, 3),
          weighted: 1,
        }));
      }

      function enrichTopOpportunity(base, signals, themes) {
        const dynamicThemes = themes.length ? themes : ["workflow", "adoption"];
        const themeLabel = dynamicThemes.slice(0, 2).map(toTitleCase).join(" + ");
        const evidence = base.evidence.length
          ? base.evidence
          : buildEvidenceFallback(signals, dynamicThemes, 6);
        const mainSummary = summarizeSignal(signals[0] || "", 120);
        const supportingSummary = summarizeSignal(signals[1] || "", 120);

        const ui = [...base.ui];
        const data = [...base.data];
        const workflow = [...base.workflow];
        if (dynamicThemes[0]) {
          ui.push(
            'Focused UX guidance for "' +
              dynamicThemes[0] +
              '" signals to reduce user friction.',
          );
          data.push("theme_" + toSnakeCase(dynamicThemes[0]) + "_impact_events");
        }
        workflow.push("Review weekly signal deltas and re-score this opportunity.");

        return {
          ...base,
          name: themeLabel ? base.name + " for " + themeLabel : base.name,
          problem:
            "Based on " +
            signals.length +
            " signals, the strongest pain points are: " +
            mainSummary +
            (supportingSummary ? " | " + supportingSummary : ""),
          ui,
          data,
          workflow,
          evidence,
          score: Math.max(base.score, 4 + dynamicThemes.length * 2),
          matchedKeywords: Array.from(
            new Set([...(base.matchedKeywords || []), ...dynamicThemes]),
          ),
        };
      }

      function buildSignalDrivenOpportunity(signals, themes) {
        const dynamicThemes = themes.length ? themes : ["activation", "clarity", "quality"];
        const label = dynamicThemes.slice(0, 2).map(toTitleCase).join(" + ");
        const mainTheme = dynamicThemes[0];
        return {
          id: "signal-driven-opportunity",
          name: "Signal-Driven Opportunity: " + label,
          problem:
            "Input data shows repeated friction around " +
            dynamicThemes.slice(0, 3).join(", ") +
            ". Build a focused feature to address this evidence directly.",
          keywords: [...dynamicThemes],
          ui: [
            "Introduce guided interactions around " + mainTheme + ".",
            "Show in-product context for affected users and steps.",
          ],
          data: [
            "signal_driven_opportunity_score",
            "theme_" + toSnakeCase(mainTheme) + "_events",
            "time_to_resolution",
          ],
          workflow: [
            "Ingest fresh signals -> ship targeted iteration -> measure outcome impact",
          ],
          score: 6 + dynamicThemes.length * 2,
          evidence: buildEvidenceFallback(signals, dynamicThemes, 8),
          matchedKeywords: dynamicThemes,
        };
      }

      function ensureEvidenceCoverage(evidence, signals, themes) {
        const next = [...(evidence || [])];
        const seen = new Set(next.map((item) => item.text));
        const fallbackKeywords = themes.length ? themes.slice(0, 3) : ["signal"];
        const uploaded = signals.filter((signal) => /\.[a-z0-9]+:\s/i.test(signal));
        const ordered = [...uploaded, ...signals];

        ordered.forEach((signal) => {
          if (next.length >= 10) return;
          if (seen.has(signal)) return;
          next.push({
            text: signal,
            keywords: fallbackKeywords,
            weighted: 1,
          });
          seen.add(signal);
        });
        return next;
      }

      function buildSignalDiagnostics(signals, ranking) {
        const candidates = (ranking || []).slice(0, 3);
        return signals.map((signal, index) => {
          let best = {
            name: "No direct match",
            impact: Math.max(1, signalWeight(signal)),
            keywords: [],
          };

          candidates.forEach((opp) => {
            const hits = getHitsForOpportunity(signal, opp);
            if (!hits.length) return;
            const impact = hits.length * 3 + signalWeight(signal);
            if (impact > best.impact || best.name === "No direct match") {
              best = {
                name: opp.name,
                impact,
                keywords: hits,
              };
            }
          });

          return {
            lineNumber: index + 1,
            signal,
            topMatch: best.name,
            impact: best.impact,
            keywords: best.keywords,
          };
        });
      }

      function buildTasks(name, mode) {
        const modeTask =
          mode === "fast"
            ? "Ship prototype in one short loop, then refine from feedback."
            : mode === "safe"
              ? "Include full validation + edge-case handling before release."
              : "Use iterative slices with quick demo checkpoints.";
        return [
          "Draft product spec and acceptance criteria for " + name + ".",
          "Implement UI surface and interaction states.",
          "Implement data model/events and analytics instrumentation.",
          "Implement workflow orchestration and permissions.",
          "Add tests + rollout checklist + telemetry validation.",
          modeTask,
        ];
      }

      function clampNumber(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function getConfidenceLabel(score) {
        if (score >= 82) return "High";
        if (score >= 68) return "Medium";
        return "Low";
      }

      function computeConfidence(top, ranking, signals, themes, matchedEvidence) {
        const second = ranking[1];
        const evidence = matchedEvidence || [];
        const signalVolume = clampNumber(signals.length / 14, 0, 1);
        const weightedEvidence = evidence.reduce(
          (sum, item) => sum + Math.max(0, Number(item.weighted) || 0),
          0,
        );
        const evidenceDensity = signals.length
          ? clampNumber(
              evidence.filter((item) => (Number(item.weighted) || 0) > 1).length /
                signals.length,
              0,
              1,
            )
          : 0;
        const evidenceStrength = signals.length
          ? clampNumber(
              (weightedEvidence / Math.max(1, signals.length * 6)) * 0.7 +
                evidenceDensity * 0.3,
              0,
              1,
            )
          : 0;
        const separation = second
          ? clampNumber(
              ((top.score - second.score) / Math.max(1, top.score)) *
                clampNumber(top.score / 35, 0, 1),
              0,
              1,
            )
          : clampNumber(top.score / 40, 0, 1);
        const specificity = clampNumber(top.matchedKeywords.length / 8, 0, 1);
        const themeStrength = clampNumber((themes || []).length / 5, 0, 1);

        const blended =
          signalVolume * 0.2 +
          evidenceStrength * 0.4 +
          separation * 0.2 +
          specificity * 0.15 +
          themeStrength * 0.05;
        const score = clampNumber(Math.round(18 + blended * 77), 18, 95);

        const reasons = [
          "Evidence strength " + Math.round(evidenceStrength * 100) + "%",
          "Top-vs-next separation " + Math.round(separation * 100) + "%",
          "Signal volume " + signals.length,
        ];

        return {
          score,
          label: getConfidenceLabel(score),
          reasons,
          metrics: {
            signalVolume,
            evidenceStrength,
            separation,
            specificity,
            themeStrength,
          },
        };
      }

      function buildPrompt(result, mode, question) {
        return [
          "Question: " + question,
          "You are implementing: " + result.name,
          "Mode: " + mode,
          "Problem: " + result.problem,
          "UI changes: " + result.ui.join("; "),
          "Data model changes: " + result.data.join("; "),
          "Workflow changes: " + result.workflow.join("; "),
          "Evidence:",
          ...result.evidence.slice(0, 6).map((e) => "- " + e.text),
          "Tasks:",
          ...result.tasks.map((t) => "- " + t),
          "Return: code diff, tests, rollout plan, and risks.",
        ].join("\n");
      }

      function renderList(id, items) {
        document.getElementById(id).innerHTML = (items || [])
          .map((item) => "<li>" + item + "</li>")
          .join("");
      }

      function renderRanking(rows) {
        document.getElementById("rankingTable").innerHTML = rows
          .map((row) => {
            return (
              "<tr><td>" +
              row.name +
              "</td><td>" +
              row.score +
              "</td><td>" +
              row.evidence.length +
              "</td><td>" +
              (row.matchedKeywords.slice(0, 6).join(", ") || "-") +
              "</td></tr>"
            );
          })
          .join("");
      }

      function renderSignalDiagnostics(rows) {
        const table = document.getElementById("signalTable");
        if (!rows || !rows.length) {
          table.innerHTML =
            '<tr><td colspan="5" class="small">No lines to process yet.</td></tr>';
          document.getElementById("lineSummary").textContent = "No lines processed yet.";
          return;
        }
        table.innerHTML = rows
          .map((row) => {
            const keywords = row.keywords && row.keywords.length
              ? row.keywords.slice(0, 6).join(", ")
              : "processed";
            return (
              "<tr><td>" +
              row.lineNumber +
              "</td><td class=\"line-text\" title=\"" +
              escapeHtml(row.signal) +
              "\">" +
              escapeHtml(row.signal) +
              "</td><td>" +
              escapeHtml(row.topMatch) +
              "</td><td>" +
              row.impact +
              "</td><td>" +
              escapeHtml(keywords) +
              "</td></tr>"
            );
          })
          .join("");
        document.getElementById("lineSummary").textContent =
          rows.length + " lines processed and scored.";
      }

      function downloadText(filename, text, type) {
        const blob = new Blob([text], { type: type || "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function getHistory() {
        try {
          const raw = localStorage.getItem(HISTORY_KEY);
          const parsed = raw ? JSON.parse(raw) : [];
          return Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          return [];
        }
      }

      function saveHistory(entry) {
        const history = getHistory();
        const next = [entry, ...history].slice(0, 10);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(next));
        renderHistory();
      }

      function renderHistory() {
        const history = getHistory();
        const container = document.getElementById("historyList");
        if (!history.length) {
          container.innerHTML = '<div class="small">No saved runs yet.</div>';
          return;
        }
        container.innerHTML = history
          .map((item, idx) => {
            return (
              '<div class="history-item">' +
              "<span>" +
              item.timestamp +
              " - " +
              item.topName +
              "</span>" +
              '<button class="btn-secondary" data-load="' +
              idx +
              '">Load</button>' +
              "</div>"
            );
          })
          .join("");
      }

      function loadHistory(index) {
        const history = getHistory();
        const item = history[index];
        if (!item) return;
        latestResult = item.payload;
        renderResult(latestResult);
        status("Loaded saved run from history.");
      }

      function renderResult(payload) {
        const top = payload.top;
        document.getElementById("topName").textContent = top.name;
        document.getElementById("topProblem").textContent = top.problem;
        const providerChip = payload.aiProvider
          ? '<span class="chip">Provider: ' + escapeHtml(payload.aiProvider) + "</span>"
          : '<span class="chip">Provider: local-fallback</span>';
        const themeChip = payload.themes && payload.themes.length
          ? '<span class="chip">Themes: ' + payload.themes.slice(0, 3).join(", ") + "</span>"
          : "";
        document.getElementById("metaChips").innerHTML =
          '<span class="chip">Confidence: ' +
          payload.confidence +
          "% (" +
          (payload.confidenceLabel || "n/a") +
          ")</span>" +
          '<span class="chip">Signals: ' +
          payload.signalCount +
          "</span>" +
          '<span class="chip">Mode: ' +
          payload.mode +
          "</span>" +
          providerChip +
          themeChip;
        const confidenceText =
          payload.confidenceReasons && payload.confidenceReasons.length
            ? "Confidence basis: " + payload.confidenceReasons.join(" | ")
            : "";
        const fallbackText = payload.aiFallbackReason
          ? " | AI fallback reason: " + payload.aiFallbackReason
          : "";
        document.getElementById("confidenceNote").textContent = confidenceText + fallbackText;

        renderList(
          "evidenceList",
          top.evidence.length
            ? top.evidence.slice(0, 8).map((ev) => ev.text + " [" + ev.keywords.join(", ") + "]")
            : ["No evidence matched. Add more specific signals."],
        );
        renderRanking(payload.ranking);
        renderList("uiChanges", top.ui);
        renderList("dataChanges", top.data);
        renderList("workflowChanges", top.workflow);
        renderList("taskList", top.tasks);
        renderSignalDiagnostics(payload.signalDiagnostics || []);
        document.getElementById("promptOutput").textContent = payload.prompt;
      }

      function buildMarkdown(payload) {
        const top = payload.top;
        return [
          "# Cursor PM Brief",
          "",
          "- Timestamp: " + payload.timestamp,
          "- Question: " + payload.question,
          "- Mode: " + payload.mode,
          "- Provider: " + (payload.aiProvider || "local-fallback"),
          "- Confidence: " + payload.confidence + "% (" + (payload.confidenceLabel || "n/a") + ")",
          "- Confidence basis: " + (payload.confidenceReasons && payload.confidenceReasons.length ? payload.confidenceReasons.join(", ") : "n/a"),
          "- Themes: " + (payload.themes && payload.themes.length ? payload.themes.join(", ") : "n/a"),
          "- Signal lines processed: " + (payload.signalDiagnostics ? payload.signalDiagnostics.length : payload.signalCount),
          "",
          "## Recommended Feature",
          top.name,
          "",
          "## Problem",
          top.problem,
          "",
          "## Evidence",
          ...top.evidence.slice(0, 10).map((e) => "- " + e.text),
          "",
          "## UI Changes",
          ...top.ui.map((x) => "- " + x),
          "",
          "## Data Changes",
          ...top.data.map((x) => "- " + x),
          "",
          "## Workflow Changes",
          ...top.workflow.map((x) => "- " + x),
          "",
          "## Delivery Tasks",
          ...top.tasks.map((x) => "- " + x),
          "",
          "## Vibe Coding Prompt",
          "```",
          payload.prompt,
          "```",
        ].join("\n");
      }

      function normalizeTextArray(values, fallback, maxItems) {
        if (!Array.isArray(values)) return fallback.slice(0, maxItems);
        const normalized = values
          .map((value) => String(value || "").trim())
          .filter(Boolean)
          .slice(0, maxItems);
        return normalized.length ? normalized : fallback.slice(0, maxItems);
      }

      function getApiTargets() {
        const targets = [];
        if (window.location && /^https?:$/i.test(window.location.protocol)) {
          targets.push(window.location.origin);
        }
        targets.push("http://localhost:3000");
        return Array.from(new Set(targets));
      }

      function sanitizeAIRecommendation(raw, fallbackTop, themes) {
        const rec = raw && typeof raw === "object" ? raw : {};
        const safeThemes = normalizeTextArray(rec.themes, themes || [], 6);
        const safeEvidence = normalizeTextArray(
          rec.evidence,
          (fallbackTop.evidence || []).map((item) => item.text || item),
          10,
        );
        const safeConfidence = Number.isFinite(Number(rec.confidence))
          ? Math.min(99, Math.max(1, Math.round(Number(rec.confidence))))
          : null;
        const safeScore = Number.isFinite(Number(rec.score))
          ? Math.max(1, Math.round(Number(rec.score)))
          : null;

        return {
          name: String(rec.name || "").trim() || fallbackTop.name,
          problem: String(rec.problem || "").trim() || fallbackTop.problem,
          ui: normalizeTextArray(rec.ui, fallbackTop.ui || [], 8),
          data: normalizeTextArray(rec.data, fallbackTop.data || [], 8),
          workflow: normalizeTextArray(rec.workflow, fallbackTop.workflow || [], 8),
          tasks: normalizeTextArray(rec.tasks, fallbackTop.tasks || [], 10),
          themes: safeThemes,
          evidence: safeEvidence,
          confidence: safeConfidence,
          score: safeScore,
        };
      }

      async function requestAIRecommendation(input) {
        if (typeof fetch !== "function") {
          return {
            ok: false,
            error: "AI router fetch unavailable in this runtime.",
          };
        }
        const targets = getApiTargets();
        let lastError = "AI router unavailable.";

        for (const baseUrl of targets) {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 12000);
          try {
            const response = await fetch(baseUrl.replace(/\/+$/, "") + "/api/recommend", {
              method: "POST",
              headers: {
                "content-type": "application/json",
              },
              body: JSON.stringify({
                question: input.question,
                mode: input.mode,
                signals: input.signals,
                history: input.history || [],
              }),
              signal: controller.signal,
            });
            clearTimeout(timeout);
            if (!response.ok) {
              const text = await response.text();
              lastError = "HTTP " + response.status + " from " + baseUrl + ": " + text;
              continue;
            }
            const data = await response.json();
            if (!data || !data.ok || !data.recommendation) {
              lastError = "Invalid AI response from " + baseUrl;
              continue;
            }
            return {
              ok: true,
              baseUrl,
              data,
            };
          } catch (error) {
            clearTimeout(timeout);
            lastError = (error && error.message) || "Unknown request error";
          }
        }

        return {
          ok: false,
          error: lastError,
        };
      }

      async function analyze(source) {
        const requestedBy = source || "manual";
        if (isAnalyzing) {
          queuedAnalyzeSource = requestedBy;
          status("Analysis queued (" + requestedBy + ") while current run finishes.");
          recordAction("Analyze queued", requestedBy);
          return;
        }

        const analyzeButton = document.getElementById("analyzeBtn");
        const initialButtonText = analyzeButton.textContent;
        isAnalyzing = true;
        analyzeButton.disabled = true;
        analyzeButton.textContent = "Analyzing...";
        recordAction("Analyze started", requestedBy);

        try {
          const question =
            document.getElementById("question").value.trim() || "What should we build next?";
          const mode = document.getElementById("mode").value;
          const interviews = splitIntoSignals(
            document.getElementById("interviews").value,
            "interview",
          );
          const usage = splitIntoSignals(document.getElementById("usage").value, "usage");
          const market = splitIntoSignals(document.getElementById("market").value, "market");
          const fileInput = document.getElementById("uploads");
          const files = Array.from(fileInput.files || []);

          status("Processing signals...");
          const uploadedSignals = [];
          for (const file of files) {
            const fileSignals = await readFileSignals(file);
            uploadedSignals.push(...fileSignals);
          }
          const signals = [...interviews, ...usage, ...market, ...uploadedSignals];
          if (!signals.length) {
            status("No signals found. Add text or upload files.");
            recordAction("Analyze completed", "0 lines");
            return;
          }

          const themes = extractThemes(signals, 5);
          let ranking = opportunities
            .map((opp) => scoreOpportunity(opp, signals))
            .sort((a, b) => b.score - a.score);

          let top = ranking[0];
          if (!top || top.score <= 0) {
            top = buildSignalDrivenOpportunity(signals, themes);
            ranking = [top, ...ranking];
          } else {
            top = enrichTopOpportunity(top, signals, themes);
            ranking = [top, ...ranking.slice(1)];
          }

          const matchedEvidence = [...top.evidence];
          top.evidence = ensureEvidenceCoverage(top.evidence, signals, themes);
          top.tasks = buildTasks(top.name, mode);
          let aiProvider = null;
          let aiModel = null;
          let aiRouteMode = null;
          let aiUsed = false;
          let aiError = "";

          const aiAttempt = await requestAIRecommendation({
            question,
            mode,
            signals,
            history: getHistory(),
          });
          if (aiAttempt.ok) {
            const aiData = aiAttempt.data;
            const aiRecommendation = sanitizeAIRecommendation(aiData.recommendation, top, themes);

            top.name = aiRecommendation.name;
            top.problem = aiRecommendation.problem;
            top.ui = aiRecommendation.ui;
            top.data = aiRecommendation.data;
            top.workflow = aiRecommendation.workflow;
            top.tasks = aiRecommendation.tasks;
            top.matchedKeywords = aiRecommendation.themes.length
              ? aiRecommendation.themes
              : top.matchedKeywords;
            top.evidence = aiRecommendation.evidence.map((line) => ({
              text: line,
              keywords: aiRecommendation.themes.slice(0, 3),
              weighted: 2,
            }));
            top.score = aiRecommendation.score || Math.max(top.score, 14 + top.evidence.length * 2);

            ranking = [
              {
                id: top.id || "ai-top",
                name: top.name,
                score: top.score,
                evidence: top.evidence,
                matchedKeywords: top.matchedKeywords,
                keywords: top.matchedKeywords,
              },
              ...ranking.slice(1),
            ];

            aiUsed = true;
            aiProvider = aiData.provider || "unknown";
            aiModel = aiData.model || "unknown";
            aiRouteMode = aiData.mode || mode;
            if (Number.isFinite(aiRecommendation.confidence)) {
              top.aiConfidence = aiRecommendation.confidence;
            }
            recordAction("AI router response", aiProvider + " / " + aiModel);
          } else {
            aiError = aiAttempt.error || "AI router unavailable";
            recordAction("AI router fallback", aiError.slice(0, 80));
          }

          let confidence = computeConfidence(top, ranking, signals, themes, matchedEvidence);
          if (Number.isFinite(top.aiConfidence)) {
            const aiScore = Math.min(99, Math.max(1, Math.round(top.aiConfidence)));
            confidence = {
              ...confidence,
              score: aiScore,
              label: getConfidenceLabel(aiScore),
              reasons: [
                "AI provider confidence " + aiScore + "%",
                ...(confidence.reasons || []),
              ].slice(0, 4),
            };
          }
          const signalDiagnostics = buildSignalDiagnostics(signals, ranking);
          const timestamp = new Date().toLocaleString();
          const prompt = buildPrompt(top, mode, question);

          const payload = {
            timestamp,
            question,
            mode,
            signalCount: signals.length,
            confidence: confidence.score,
            confidenceLabel: confidence.label,
            confidenceReasons: confidence.reasons,
            themes,
            top,
            signalDiagnostics,
            aiProvider,
            aiModel,
            aiRouteMode,
            aiFallbackReason: aiUsed ? "" : aiError,
            ranking: ranking.slice(0, 6).map((item) => ({
              name: item.name,
              score: item.score,
              evidence: item.evidence,
              matchedKeywords: item.matchedKeywords,
            })),
            prompt,
          };

          latestResult = payload;
          renderResult(payload);
          saveHistory({
            timestamp,
            topName: top.name,
            payload,
          });
          analysisRunCount += 1;
          status(
            "Recommendation generated from " +
              signals.length +
              " signals (run #" +
              analysisRunCount +
              " at " +
              new Date().toLocaleTimeString() +
              ", source: " +
              requestedBy +
              (aiUsed
                ? ", provider: " + aiProvider + "/" + aiModel + "."
                : ", local fallback." + (aiError ? " (" + aiError + ")" : "")) +
              ")",
          );
          recordAction("Analyze completed", signals.length + " lines processed");
        } finally {
          isAnalyzing = false;
          analyzeButton.disabled = false;
          analyzeButton.textContent = initialButtonText;
          if (queuedAnalyzeSource) {
            const replaySource = queuedAnalyzeSource;
            queuedAnalyzeSource = null;
            setTimeout(() => {
              analyze(replaySource).catch((error) => {
                status("Failed to analyze: " + error.message);
                recordAction("Analyze failed", error.message);
              });
            }, 0);
          }
        }
      }

      function debounce(fn, wait) {
        let timer = null;
        return (...args) => {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => fn(...args), wait);
        };
      }

      function requestAnalyze(source) {
        analyze(source).catch((error) => {
          status("Failed to analyze: " + error.message);
          recordAction("Analyze failed", error.message);
        });
      }

      const scheduleAnalyze = debounce((source) => {
        requestAnalyze(source || "auto-input");
      }, 450);

      ["question", "interviews", "usage", "market"].forEach((id) => {
        document.getElementById(id).addEventListener("input", () => {
          status("Input updated. Re-analyzing...");
          scheduleAnalyze("typing-" + id);
        });
      });
      document.getElementById("mode").addEventListener("change", () => {
        status("Mode changed. Re-analyzing...");
        scheduleAnalyze("mode-change");
      });
      document.getElementById("uploads").addEventListener("change", () => {
        const fileCount = (document.getElementById("uploads").files || []).length;
        recordAction("Upload changed", fileCount + " file(s)");
        status("Files added. Re-analyzing...");
        requestAnalyze("file-upload");
      });

      document.getElementById("analyzeBtn").addEventListener("click", () => {
        recordAction("Analyze clicked", "manual");
        requestAnalyze("analyze-button");
      });

      document.getElementById("exportJsonBtn").addEventListener("click", () => {
        recordAction("Export JSON clicked", latestResult ? "ready" : "no-result");
        if (!latestResult) {
          status("Generate a recommendation before exporting.");
          return;
        }
        downloadText(
          "cursor-pm-brief.json",
          JSON.stringify(latestResult, null, 2),
          "application/json;charset=utf-8",
        );
        status("Exported JSON brief.");
      });

      document.getElementById("exportMdBtn").addEventListener("click", () => {
        recordAction("Export Markdown clicked", latestResult ? "ready" : "no-result");
        if (!latestResult) {
          status("Generate a recommendation before exporting.");
          return;
        }
        downloadText(
          "cursor-pm-brief.md",
          buildMarkdown(latestResult),
          "text/markdown;charset=utf-8",
        );
        status("Exported Markdown brief.");
      });

      document.getElementById("historyList").addEventListener("click", (event) => {
        const loadIndex = event.target.getAttribute("data-load");
        if (loadIndex === null) return;
        recordAction("History load clicked", "entry " + (Number(loadIndex) + 1));
        loadHistory(Number(loadIndex));
      });

      document.getElementById("clearHistoryBtn").addEventListener("click", () => {
        recordAction("Clear history clicked");
        localStorage.removeItem(HISTORY_KEY);
        renderHistory();
        status("Cleared saved history.");
      });

      renderHistory();
      renderSignalDiagnostics([]);
      requestAnalyze("initial-load");
    </script>
  </body>
</html>
